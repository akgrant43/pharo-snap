/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-eem.2306 uuid: 0c680904-c828-4af4-ad2c-06fe3b7da899
   from
	FileAttributesPlugin FileAttributesPlugin.oscog-AlistairGrant.25 uuid: 5b76e8bb-69e1-4db4-b529-9de1249e63e0
 */
static char __buildInfo[] = "FileAttributesPlugin FileAttributesPlugin.oscog-AlistairGrant.25 uuid: 5b76e8bb-69e1-4db4-b529-9de1249e63e0 " __DATE__ ;



#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <limits.h>
#include <sys/types.h>
#include <dirent.h>
#ifdef WIN32
#include <windows.h>
#include <winbase.h>
#define FAIL() { return -1; }
#include "sqWin32File.h"
#endif
typedef struct dirptrstruct {
    		DIR *dp;
		int path_len;
    		char *path_file;
   		char path[PATH_MAX+4];
    		} osdir;
#include <sys/stat.h>
#if !defined(HAVE_LSTAT) && !defined(WIN32)
#define HAVE_LSTAT 1
#endif
#include <unistd.h>
/* AKG 2017 - FileAttributesPlugin.c translated from class FileAttributesPlugin */

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
#endif

#include "sqMemoryAccess.h"


/*** Constants ***/
#define PrimErrBadArgument 3
#define PrimErrNoMemory 9


/*** Function Prototypes ***/
static sqInt accessAttributesForFilenameintostartingAt(char *cPathName, sqInt attributeArray, sqInt offset);
static sqInt addressObjectFor(void *aMachineAddress);
static sqInt byteArrayFromCStringto(const char *aCString, sqInt *byteArrayOop);
static sqInt canOpenDirectoryStreamForlength(char *aPathCString, sqInt length);
static sqInt canStatFilePathlength(char *aPathCString, sqInt length);
EXPORT(sqInt) checkAccessmodeto(sqInt pathString, sqInt mode, sqInt *flag);
static sqInt fileCreationTimeForlengthto(char *pathString, sqInt pathLength, time_t *creationDate);
static int fileToAttributeArraymaskarray(char *cPathName, sqInt attributeMask, sqInt *attributeArray);
EXPORT(const char*) getModuleName(void);
EXPORT(sqInt) initialiseModule(void);
static sqInt isSymlinkboolean(char *cPathName, sqInt *resultOop);
#if WIN32
static sqInt offsetStatBufTimesForWIN32(struct stat *statBufPointer);
#endif /* WIN32 */
static sqInt oopFromTimeT(time_t posixSeconds);
static int openDirectoryStreamptr(sqInt pathOOP, osdir **osdirPtr);
static int pathOoptoBuffermaxLen(sqInt pathNameOop, char *cPathName, sqInt maxLen);
static void * pointerFrom(sqInt directoryPointerBytes);
EXPORT(sqInt) primitiveClosedir(void);
EXPORT(sqInt) primitiveFileAttribute(void);
EXPORT(sqInt) primitiveFileAttributes(void);
EXPORT(sqInt) primitiveFileExists(void);
EXPORT(sqInt) primitiveFileMasks(void);
EXPORT(sqInt) primitiveLogicalDrives(void);
EXPORT(sqInt) primitiveOpendir(void);
EXPORT(sqInt) primitivePathMax(void);
EXPORT(sqInt) primitiveReaddir(void);
EXPORT(sqInt) primitiveRewinddir(void);
EXPORT(sqInt) primitiveVersionString(void);
static sqInt putLStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop);
static sqInt putStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop);
static sqInt readLinkintomaxLength(char *cPathName, char *cLinkPtr, size_t maxLength);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
static sqInt statArrayFortoArrayfromfileName(char *cPathName, sqInt attributeArray, struct stat *statBufPointer, sqInt fileNameOop);
static sqInt stringFromCString(const char *aCString);


/*** Variables ***/
static int hasSecurityPlugin = 1;

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static void * (*arrayValueOf)(sqInt oop);
static sqInt (*classArray)(void);
static sqInt (*classByteArray)(void);
static sqInt (*classString)(void);
static sqInt (*failed)(void);
static sqInt (*falseObject)(void);
static sqInt (*instantiateClassindexableSize)(sqInt classPointer, sqInt size);
static sqInt (*integerObjectOf)(sqInt value);
static void * (*ioLoadFunctionFrom)(char *functionName, char *moduleName);
static sqInt (*isKindOf)(sqInt oop, char *aString);
static sqInt (*nilObject)(void);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop);
static sqInt (*popRemappableOop)(void);
static sqInt (*positive32BitIntegerFor)(unsigned int integerValue);
static sqInt (*positive64BitIntegerFor)(usqLong integerValue);
static sqInt (*primitiveFail)(void);
static sqInt (*primitiveFailFor)(sqInt reasonCode);
static sqInt (*primitiveFailForOSError)(sqLong osError);
static sqInt (*pushRemappableOop)(sqInt oop);
static sqInt (*signed32BitIntegerFor)(sqInt integerValue);
static sqInt (*signed64BitIntegerFor)(sqLong integerValue);
static sqInt (*sizeOfSTArrayFromCPrimitive)(void *cPtr);
static sqInt (*stSizeOf)(sqInt oop);
static sqInt (*stackIntegerValue)(sqInt offset);
static sqInt (*stackObjectValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
static sqInt (*storePointerofObjectwithValue)(sqInt index, sqInt oop, sqInt valuePointer);
static sqInt (*trueObject)(void);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern void * arrayValueOf(sqInt oop);
extern sqInt classArray(void);
extern sqInt classByteArray(void);
extern sqInt classString(void);
extern sqInt failed(void);
extern sqInt falseObject(void);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
extern sqInt integerObjectOf(sqInt value);
extern void * ioLoadFunctionFrom(char *functionName, char *moduleName);
extern sqInt isKindOf(sqInt oop, char *aString);
extern sqInt nilObject(void);
extern sqInt popthenPush(sqInt nItems, sqInt oop);
extern sqInt popRemappableOop(void);
extern sqInt positive32BitIntegerFor(unsigned int integerValue);
extern sqInt positive64BitIntegerFor(usqLong integerValue);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt primitiveFailForOSError(sqLong osError);
extern sqInt pushRemappableOop(sqInt oop);
extern sqInt signed32BitIntegerFor(sqInt integerValue);
extern sqInt signed64BitIntegerFor(sqLong integerValue);
extern sqInt sizeOfSTArrayFromCPrimitive(void *cPtr);
extern sqInt stSizeOf(sqInt oop);
extern sqInt stackIntegerValue(sqInt offset);
extern sqInt stackObjectValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern sqInt storePointerofObjectwithValue(sqInt index, sqInt oop, sqInt valuePointer);
extern sqInt trueObject(void);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"FileAttributesPlugin FileAttributesPlugin.oscog-AlistairGrant.25 (i)"
#else
	"FileAttributesPlugin FileAttributesPlugin.oscog-AlistairGrant.25 (e)"
#endif
;
static void * sCLPfn;
static void * sCOFfn;



/*	Call access() for each access type (R, W, X) on the c string cPathName,
	storing the results in the st array attributeArray.
 */

	/* FileAttributesPlugin>>#accessAttributesForFilename:into:startingAt: */
static sqInt
accessAttributesForFilenameintostartingAt(char *cPathName, sqInt attributeArray, sqInt offset)
{
    sqInt boolean;
    sqInt index;

	index = offset;
	if ((access(cPathName, R_OK)) == 0) {
		boolean = trueObject();
	}
	else {
		boolean = falseObject();
	}
	storePointerofObjectwithValue(index, attributeArray, boolean);
	index += 1;
	boolean = ((access(cPathName, W_OK)) == 0
		? trueObject()
		: falseObject());
	storePointerofObjectwithValue(index, attributeArray, boolean);
	index += 1;
	boolean = ((access(cPathName, X_OK)) == 0
		? trueObject()
		: falseObject());
	storePointerofObjectwithValue(index, attributeArray, boolean);
	return 0;
}


/*	Answer an ExternalAddress object which represents aMachineAddress */

	/* FileAttributesPlugin>>#addressObjectFor: */
static sqInt
addressObjectFor(void *aMachineAddress)
{
    sqInt addressOop;
    unsigned char *addressOopArrayPointer;
    union {void *address; unsigned char bytes[sizeof(void *)];} addressUnion;
    sqInt idx;

	addressOop = instantiateClassindexableSize(classByteArray(), sizeof(void *));
	if (!(addressOop)) {
		return primitiveFailFor(PrimErrNoMemory);
	}
	addressOopArrayPointer = arrayValueOf(addressOop);
	addressUnion.address = aMachineAddress;
	idx = 0;
	while (idx < (sizeof(void *))) {
		addressOopArrayPointer[idx] = addressUnion.bytes[idx];
		idx += 1;
	}
	return addressOop;
}


/*	Answer a new ByteArray copied from a null-terminated C string.
	Caution: This may invoke the garbage collector. */

	/* FileAttributesPlugin>>#byteArrayFromCString:to: */
static sqInt
byteArrayFromCStringto(const char *aCString, sqInt *byteArrayOop)
{
    unsigned char *byteArrayPtr;
    sqInt len;
    sqInt newByteArray;


	/* We never return strings longer than PATH_MAX */
	len = strlen(aCString);
	if (len > PATH_MAX) {
		return -1 /* stringTooLong */;
	}
	newByteArray = instantiateClassindexableSize(classByteArray(), len);
	if (!(newByteArray)) {
		return primitiveFailFor(PrimErrNoMemory);
	}
	byteArrayPtr = arrayValueOf(newByteArray);
	memcpy(byteArrayPtr, aCString, len);
	byteArrayOop[0] = newByteArray;
	return 0;
}


/*	Answer non-zero if security permits the directory to be listed. */
/*	FIXME: This function has not been tested. -dtl */
/*	If the security plugin can be loaded, use it to check . 
	If not, assume it's ok */
/*	The hasSecurityPlugin flag is set to 1 by default */

	/* FileAttributesPlugin>>#canOpenDirectoryStreamFor:length: */
static sqInt
canOpenDirectoryStreamForlength(char *aPathCString, sqInt length)
{
	if (hasSecurityPlugin == 0) {
		return 1;
	}
	if (sCLPfn != 0) {
		return  ((int (*) (char *, int)) sCLPfn)(aPathCString, length);
	}
	else {

		/* Reset the flag so we do not try again next time */
		hasSecurityPlugin = 0;
		return 1;
	}
}


/*	Answer non-zero if security permits the a stat() call on the file path.
	Allow a
	stat() call only on files which we are permitted to open.
 */
/*	FIXME: This function has not been tested. -dtl */
/*	If the security plugin can be loaded, use it to check . 
	If not, assume it's ok */
/*	The hasSecurityPlugin flag is set to 1 by default */

	/* FileAttributesPlugin>>#canStatFilePath:length: */
static sqInt
canStatFilePathlength(char *aPathCString, sqInt length)
{
	if (hasSecurityPlugin == 0) {
		return 1;
	}
	if (sCOFfn != 0) {
		return  ((int (*) (char *, int, int)) sCOFfn)(aPathCString, length, 0);
	}
	else {

		/* Reset the flag so we do not try again next time */
		hasSecurityPlugin = 0;
		return 1;
	}
}


/*	Check access to pathString. */

	/* FileAttributesPlugin>>#checkAccess:mode:to: */
EXPORT(sqInt)
checkAccessmodeto(sqInt pathString, sqInt mode, sqInt *flag)
{
    char cString[PATH_MAX];
    sqInt len;
    char *sPtr;


	/* Note: The static sized string buffer is faster than using a Smalltalk allocated
	   string as the buffer, and is unlikely to fail in practice. In the event that
	   the buffer turns out to be too small, write an error message to stdout before
	   failing. */
	len = stSizeOf(pathString);
	if (len >= PATH_MAX) {
		return -1 /* stringTooLong */;
	}
	sPtr = arrayValueOf(pathString);
	if ((canStatFilePathlength(sPtr, len)) == 0) {
		/* begin cantStatPath */
		return -3;
	}
	memcpy(cString, sPtr, len);
	cString[len] = 0;
	flag[0] = (access(cString, mode));
	return 0;
}


/*	Get the creationDate for the supplied file.
	Linux kernel 4.11 should have statx(), so hopefully there will be a
	cross-platform solution soon. Just dump the c-code and hope to remove it
	soon. 
 */

	/* FileAttributesPlugin>>#fileCreationTimeFor:length:to: */
static sqInt
fileCreationTimeForlengthto(char *pathString, sqInt pathLength, time_t *creationDate)
{
    struct tm tm;

	
#ifdef WIN32
  WIN32_FILE_ATTRIBUTE_DATA winAttrs;
  WCHAR *win32Path;
  SYSTEMTIME sysTime;
#endif

  memset(&tm, 0, sizeof(tm));

#ifdef WIN32
  /* convert the supplied path name into a wide string */
  ALLOC_WIN32_PATH(win32Path, pathString, pathLength);
	if ((GetFileAttributesExW(win32Path, 0, &winAttrs)) == 0) {
		return -4 /* getAttributesFailed */;
	}
	if ((FileTimeToSystemTime(&winAttrs.ftCreationTime, &sysTime)) == 0) {
		return -5 /* timeConversionFailed */;
	}
	
  tm.tm_year = sysTime.wYear - 1900;
  tm.tm_mon = sysTime.wMonth - 1;
  tm.tm_mday = sysTime.wDay;

  tm.tm_hour = sysTime.wHour;
  tm.tm_min = sysTime.wMinute;
  tm.tm_sec = sysTime.wSecond;
  tm.tm_isdst = 0;
#endif

  *creationDate = mktime(&tm);
	return 0;
}


/*	Answer a file attribute array from pathNameOop. */

	/* FileAttributesPlugin>>#fileToAttributeArray:mask:array: */
static int
fileToAttributeArraymaskarray(char *cPathName, sqInt attributeMask, sqInt *attributeArray)
{
    sqInt accessArray;
    sqInt boolean;
    char cLinkName[PATH_MAX];
    sqInt combinedArray;
    time_t creationDate;
    sqInt fileNameOop;
    int getAccess;
    int getStats;
    sqInt index;
    sqInt len;
    sqInt sizeIfFile;
    sqInt statArray;
    struct stat statBuf;
    struct stat *statBufPointer;
    struct stat *statBufPointer1;
    struct stat *statBufPointer2;
    sqInt status;
    sqInt status1;
    sqInt status2;
    sqInt status3;
    int useLstat;
    sqInt val;


	/* Determine which attributes to retrieve */
	accessArray = 0;
	fileNameOop = 0;
	statArray = 0;
	val = 0;
	getStats = attributeMask & 1;
	getAccess = attributeMask & 2;
	if (!(getStats
		 || (getAccess))) {

		/* No information has been requested, which doesn't make sense */
		return -6 /* invalidArguments */;
	}
	if (getStats) {
		useLstat = attributeMask & 4;
		statArray = instantiateClassindexableSize(classArray(), 12);
		if (!(statArray)) {
			return primitiveFailFor(PrimErrNoMemory);
		}
		if (useLstat) {
			/* begin putLStatFor:intoBuffer:targetName: */
			statBufPointer2 = ((struct stat *) ((&statBuf)));
			
#      if HAVE_LSTAT == 1
			status3 = lstat(cPathName, statBufPointer2);
			if (status3 != 0) {
				/* begin cantStatPath */
				status = -3;
				goto l5;
			}
			if ((S_ISLNK((statBufPointer2->st_mode))) == 0) {
				((&fileNameOop))[0] = (nilObject());
			}
			else {
				len = readLinkintomaxLength(cPathName, cLinkName, PATH_MAX);
				if (len < 0) {
					status = len;
					goto l5;
				}
				status3 = byteArrayFromCStringto(cLinkName, (&fileNameOop));
			}
#      else /* HAVE_LSTAT == 1 */

			/* #HAVE_LSTAT = 1 */
			/* begin invalidRequest */
			status3 = -11;
#      endif /* HAVE_LSTAT == 1 */
			status = status3;
	l5:	/* end putLStatFor:intoBuffer:targetName: */;
		}
		else {
			/* begin putStatFor:intoBuffer:targetName: */
			statBufPointer = ((struct stat *) ((&statBuf)));
			status1 = stat(cPathName, statBufPointer);
			if (status1 != 0) {
				/* begin cantStatPath */
				status = -3;
				goto l1;
			}
			
#      if defined(WIN32)
			offsetStatBufTimesForWIN32(statBufPointer);
#      endif /* defined(WIN32) */
			((&fileNameOop))[0] = (nilObject());
			status = 0;
	l1:	/* end putStatFor:intoBuffer:targetName: */;
		}
		if (status != 0) {
			return status;
		}
		/* begin statArrayFor:toArray:from:fileName: */
		statBufPointer1 = ((struct stat *) ((&statBuf)));
		sizeIfFile = ((S_ISDIR((statBufPointer1->st_mode))) == 0
			? (statBufPointer1->st_size)
			: 0);
		storePointerofObjectwithValue(0, statArray, fileNameOop);
		storePointerofObjectwithValue(1, statArray, (BytesPerWord == 8
			? positive64BitIntegerFor((statBufPointer1->st_mode))
			: positive32BitIntegerFor((statBufPointer1->st_mode))));
		storePointerofObjectwithValue(2, statArray, positive64BitIntegerFor((statBufPointer1->st_ino)));
		storePointerofObjectwithValue(3, statArray, positive64BitIntegerFor((statBufPointer1->st_dev)));
		storePointerofObjectwithValue(4, statArray, positive64BitIntegerFor((statBufPointer1->st_nlink)));
		storePointerofObjectwithValue(5, statArray, (BytesPerWord == 8
			? positive64BitIntegerFor((statBufPointer1->st_uid))
			: positive32BitIntegerFor((statBufPointer1->st_uid))));
		storePointerofObjectwithValue(6, statArray, (BytesPerWord == 8
			? positive64BitIntegerFor((statBufPointer1->st_gid))
			: positive32BitIntegerFor((statBufPointer1->st_gid))));
		storePointerofObjectwithValue(7, statArray, positive64BitIntegerFor(sizeIfFile));
		storePointerofObjectwithValue(8, statArray, oopFromTimeT((statBufPointer1->st_atime)));
		storePointerofObjectwithValue(9, statArray, oopFromTimeT((statBufPointer1->st_mtime)));
		storePointerofObjectwithValue(10, statArray, oopFromTimeT((statBufPointer1->st_ctime)));
		
#    if defined(WIN32)
		status2 = fileCreationTimeForlengthto(cPathName, strlen(cPathName), (&creationDate));
		storePointerofObjectwithValue(11, statArray, (status2 == 0
			? (/* begin oopFromTimeT: */
				((sizeof(time_t)) == 4
						? (signed32BitIntegerFor(creationDate),
							goto l2)
						: 0),
				signed64BitIntegerFor(creationDate),
	l2:	/* end oopFromTimeT: */)
			: nilObject()));
#    else /* defined(WIN32) */
		storePointerofObjectwithValue(11, statArray, nilObject());
#    endif /* defined(WIN32) */
		status = 0;
		if (status != 0) {
			return status;
		}
		attributeArray[0] = statArray;
	}
	if (getAccess) {
		accessArray = instantiateClassindexableSize(classArray(), 3);
		if (!(accessArray)) {
			return primitiveFailFor(PrimErrNoMemory);
		}
		/* begin accessAttributesForFilename:into:startingAt: */
		index = 0;
		if ((access(cPathName, R_OK)) == 0) {
			boolean = trueObject();
		}
		else {
			boolean = falseObject();
		}
		storePointerofObjectwithValue(index, accessArray, boolean);
		index += 1;
		boolean = ((access(cPathName, W_OK)) == 0
			? trueObject()
			: falseObject());
		storePointerofObjectwithValue(index, accessArray, boolean);
		index += 1;
		boolean = ((access(cPathName, X_OK)) == 0
			? trueObject()
			: falseObject());
		storePointerofObjectwithValue(index, accessArray, boolean);
		attributeArray[0] = accessArray;
	}
	if (getStats
	 && (getAccess)) {
		combinedArray = instantiateClassindexableSize(classArray(), 2);
		if (!(combinedArray)) {
			return primitiveFailFor(PrimErrNoMemory);
		}
		attributeArray[0] = combinedArray;
		storePointerofObjectwithValue(0, combinedArray, statArray);
		storePointerofObjectwithValue(1, combinedArray, accessArray);
	}
	return 0;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

	/* FileAttributesPlugin>>#initialiseModule */
EXPORT(sqInt)
initialiseModule(void)
{
	extern sqInt sqFileInit(void);
	sCOFfn = ioLoadFunctionFrom("secCanOpenFileOfSizeWritable", "SecurityPlugin");
	sCLPfn = ioLoadFunctionFrom("secCanListPathOfSize", "SecurityPlugin");
	return sqFileInit();
}


/*	Set resultOop to a boolean indicating whether cPathName is a symbolic
	link. Answer status (0 = success) */

	/* FileAttributesPlugin>>#isSymlink:boolean: */
static sqInt
isSymlinkboolean(char *cPathName, sqInt *resultOop)
{
    struct stat statBuf;
    sqInt status;

	
#  if HAVE_LSTAT == 1
	status = lstat(cPathName, (&statBuf));
	if (status != 0) {
		/* begin cantStatPath */
		return -3;
	}
	if ((S_ISLNK((statBuf.st_mode))) == 0) {
		resultOop[0] = (falseObject());
	}
	else {
		resultOop[0] = (trueObject());
	}
#  endif /* HAVE_LSTAT == 1 */
	return 0;
}

	/* FileAttributesPlugin>>#offsetStatBufTimesForWIN32: */
#if WIN32
static sqInt
offsetStatBufTimesForWIN32(struct stat *statBufPointer)
{
    TIME_ZONE_INFORMATION dtzi;
    sqInt status;

	status = GetTimeZoneInformation((&dtzi));
	if (status == 2) {
		statBufPointer->st_atime -= 3600;
		statBufPointer->st_mtime -= 3600;
		statBufPointer->st_ctime -= 3600;
	}
	return 0;
}
#endif /* WIN32 */


/*	Answer an object representation of the provided time (time_t).
	The size of time_t is platform dependent, so check the size and convert
	appropriately. 
 */

	/* FileAttributesPlugin>>#oopFromTimeT: */
static sqInt
oopFromTimeT(time_t posixSeconds)
{
	if ((sizeof(time_t)) == 4) {
		return signed32BitIntegerFor(posixSeconds);
	}
	return signed64BitIntegerFor(posixSeconds);
}


/*	Open a new directory stream. Answer a pointer to the directory stream or
	NULL. 
 */

	/* FileAttributesPlugin>>#openDirectoryStream:ptr: */
static int
openDirectoryStreamptr(sqInt pathOOP, osdir **osdirPtr)
{
    osdir *dir;
    sqInt len;
    char *sPtr;

	sPtr = arrayValueOf(pathOOP);

	/* The path buffer needs room for a trailing slash and the file name, so subtracting 2 is conservative */
	len = sizeOfSTArrayFromCPrimitive(sPtr);
	if (len > (PATH_MAX - 2)) {
		return -1 /* stringTooLong */;
	}
	if (canOpenDirectoryStreamForlength(sPtr, len)) {
		dir = (osdir *) malloc(sizeof(osdir));
		if (dir == null) {
			/* begin cantAllocateMemory */
			return ((sqInt) -10);
		}
		memcpy((dir->path), sPtr, len);
		if (dir->path[len-1] != '/') {
				dir->path[len++] = '/';
				}
		dir->path_file = dir->path + len;
		dir->path_file[0] = '\0';
		dir->path_len = len;
		dir->dp =  opendir(dir->path);
		if (!((dir->dp))) {
			free(dir);
			/* begin cantOpenDir */
			return ((sqInt) -9);
		}
		osdirPtr[0] = dir;
		return 0;
	}
	/* begin cantOpenDir */
	return ((sqInt) -9);
}


/*	Copy the supplied path name string object to the supplied c string buffer */

	/* FileAttributesPlugin>>#pathOop:toBuffer:maxLen: */
static int
pathOoptoBuffermaxLen(sqInt pathNameOop, char *cPathName, sqInt maxLen)
{
    sqInt len;
    char *sPtr;

	len = stSizeOf(pathNameOop);
	if (len >= maxLen) {
		return -1 /* stringTooLong */;
	}
	sPtr = arrayValueOf(pathNameOop);
	if ((canStatFilePathlength(sPtr, len)) == 0) {
		/* begin cantStatPath */
		return ((sqInt) -3);
	}
	memcpy(cPathName, sPtr, len);
	cPathName[len] = 0;
	return 0;
}


/*	Answer the machine address contained in anExternalAddressOop. */

	/* FileAttributesPlugin>>#pointerFrom: */
static void *
pointerFrom(sqInt directoryPointerBytes)
{
    union {void *address; unsigned char bytes[sizeof(void *)];} addressUnion;
    sqInt idx;
    unsigned char *ptr;

	if (!((isKindOf(directoryPointerBytes, "ByteArray"))
		 && ((stSizeOf(directoryPointerBytes)) == (sizeof(void *))))) {
		return null;
	}
	ptr = arrayValueOf(directoryPointerBytes);
	idx = 0;
	while (idx < (sizeof(void *))) {
		addressUnion.bytes[idx] = ptr[idx];
		idx += 1;
	}
	return addressUnion.address;
}


/*	Close the directory stream for dirPointerOop. Answer dirPointerOop on
	success. Raise PrimErrBadArgument if the parameter is not a ByteArray
	length size(void *).
	If closedir() returns an error raise PrimitiveOSError.
 */

	/* FileAttributesPlugin>>#primitiveClosedir */
EXPORT(sqInt)
primitiveClosedir(void)
{
    sqInt dirPointerOop;
    osdir *dirStream;
    sqInt result;

	dirPointerOop = stackValue(0);
	dirStream = pointerFrom(dirPointerOop);
	if (!(dirStream)) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	result = closedir((dirStream->dp));
	if (!(result == 0)) {
		return primitiveFailForOSError(-12 /* unableToCloseDir */);
	}
	free(dirStream);
	popthenPush(2, dirPointerOop);
	return 0;
}


/*	Answer a single file attribute.
	primFileAttributes: aString attributeNumber: attributeNumber
	aString is the path to the file
	attributeNumber identifies which attribute to return:
	1 - 12: stat(): name, mode, ino, dev, nlink, uid, gid, size, accessDate,
	modifiedDate, changeDate, creationDate
	13 - 15: access(): R_OK, W_OK, X_OK
	16: isSymlink
	On error, answer a single element array containing the appropriate error
	code. 
 */

	/* FileAttributesPlugin>>#primitiveFileAttribute */
EXPORT(sqInt)
primitiveFileAttribute(void)
{
    sqInt attributeNumber;
    char cPathName[PATH_MAX];
    time_t creationDate;
    sqInt fileName;
    sqInt fileNameOop;
    sqInt mode;
    time_t posixSeconds;
    time_t posixSeconds1;
    time_t posixSeconds2;
    sqInt resultOop;
    sqInt *resultOop1;
    sqInt sizeIfFile;
    struct stat statBuf;
    struct stat statBuf1;
    struct stat *statBufPointer;
    sqInt status;
    sqInt status1;
    sqInt status2;
    sqInt val;
    usqIntptr_t value;
    usqIntptr_t value1;
    usqIntptr_t value2;

	fileNameOop = 0;
	mode = 0;
	val = 0;
	fileName = stackObjectValue(1);
	attributeNumber = stackIntegerValue(0);
	if ((failed())
	 || ((!(((attributeNumber >= 1) && (attributeNumber <= 16))))
	 || (!(isKindOf(fileName, "String"))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	status = pathOoptoBuffermaxLen(fileName, cPathName, PATH_MAX);
	if (status != 0) {
		return primitiveFailForOSError(status);
	}
	resultOop = 0;
	if (attributeNumber < 12) {

		/* Get requested stat entry */
		/* begin putStatFor:intoBuffer:targetName: */
		statBufPointer = ((struct stat *) ((&statBuf)));
		status2 = stat(cPathName, statBufPointer);
		if (status2 != 0) {
			/* begin cantStatPath */
			status = -3;
			goto l13;
		}
		
#    if defined(WIN32)
		offsetStatBufTimesForWIN32(statBufPointer);
#    endif /* defined(WIN32) */
		((&fileNameOop))[0] = (nilObject());
		status = 0;
	l13:	/* end putStatFor:intoBuffer:targetName: */;
		if (status != 0) {
			return primitiveFailForOSError(status);
		}
		if (attributeNumber == 1) {
			resultOop = fileNameOop;
		}
		if (attributeNumber == 2) {
			/* begin positiveMachineIntegerFor: */
			value = (statBuf.st_mode);
			resultOop = (BytesPerWord == 8
				? positive64BitIntegerFor(value)
				: positive32BitIntegerFor(value));
		}
		if (attributeNumber == 3) {
			resultOop = positive64BitIntegerFor((statBuf.st_ino));
		}
		if (attributeNumber == 4) {
			resultOop = positive64BitIntegerFor((statBuf.st_dev));
		}
		if (attributeNumber == 5) {
			resultOop = positive64BitIntegerFor((statBuf.st_nlink));
		}
		if (attributeNumber == 6) {
			/* begin positiveMachineIntegerFor: */
			value1 = (statBuf.st_uid);
			resultOop = (BytesPerWord == 8
				? positive64BitIntegerFor(value1)
				: positive32BitIntegerFor(value1));
		}
		if (attributeNumber == 7) {
			/* begin positiveMachineIntegerFor: */
			value2 = (statBuf.st_gid);
			resultOop = (BytesPerWord == 8
				? positive64BitIntegerFor(value2)
				: positive32BitIntegerFor(value2));
		}
		if (attributeNumber == 8) {
			sizeIfFile = ((S_ISDIR((statBuf.st_mode))) == 0
				? (statBuf.st_size)
				: 0);
			/* begin positiveMachineIntegerFor: */
			resultOop = (BytesPerWord == 8
				? positive64BitIntegerFor(sizeIfFile)
				: positive32BitIntegerFor(sizeIfFile));
		}
		if (attributeNumber == 9) {
			/* begin oopFromTimeT: */
			posixSeconds = ((time_t) ((statBuf.st_atime)));
			if ((sizeof(time_t)) == 4) {
				resultOop = signed32BitIntegerFor(posixSeconds);
				goto l5;
			}
			resultOop = signed64BitIntegerFor(posixSeconds);
	l5:	/* end oopFromTimeT: */;
		}
		if (attributeNumber == 10) {
			/* begin oopFromTimeT: */
			posixSeconds1 = ((time_t) ((statBuf.st_mtime)));
			if ((sizeof(time_t)) == 4) {
				resultOop = signed32BitIntegerFor(posixSeconds1);
				goto l6;
			}
			resultOop = signed64BitIntegerFor(posixSeconds1);
	l6:	/* end oopFromTimeT: */;
		}
		if (attributeNumber == 11) {
			/* begin oopFromTimeT: */
			posixSeconds2 = ((time_t) ((statBuf.st_ctime)));
			if ((sizeof(time_t)) == 4) {
				resultOop = signed32BitIntegerFor(posixSeconds2);
				goto l7;
			}
			resultOop = signed64BitIntegerFor(posixSeconds2);
	l7:	/* end oopFromTimeT: */;
		}
	}
	else {
		if (attributeNumber == 12) {
			status = fileCreationTimeForlengthto(cPathName, strlen(cPathName), (&creationDate));
			if (status != 0) {
				return primitiveFailForOSError(status);
			}
			/* begin oopFromTimeT: */
			if ((sizeof(time_t)) == 4) {
				resultOop = signed32BitIntegerFor(creationDate);
				goto l8;
			}
			resultOop = signed64BitIntegerFor(creationDate);
	l8:	/* end oopFromTimeT: */;
		}
		else {
			if (attributeNumber < 16) {

				/* Get requested access entry */
				if (attributeNumber == 13) {
					/* begin fileReadableFlag */
					mode = R_OK;
				}
				if (attributeNumber == 14) {
					/* begin fileWriteableFlag */
					mode = W_OK;
				}
				if (attributeNumber == 15) {
					/* begin fileExecutableFlag */
					mode = X_OK;
				}
				resultOop = ((access(cPathName, mode)) == 0
					? trueObject()
					: falseObject());
			}
			else {

				/* attributeNumber = 16 */
				/* begin isSymlink:boolean: */
				resultOop1 = ((sqInt *) ((&resultOop)));
				
#        if HAVE_LSTAT == 1
				status1 = lstat(cPathName, (&statBuf1));
				if (status1 != 0) {
					/* begin cantStatPath */
					status = -3;
					goto l12;
				}
				if ((S_ISLNK((statBuf1.st_mode))) == 0) {
					resultOop1[0] = (falseObject());
				}
				else {
					resultOop1[0] = (trueObject());
				}
#        endif /* HAVE_LSTAT == 1 */
				status = 0;
	l12:	/* end isSymlink:boolean: */;
				if (status != 0) {
					return primitiveFailForOSError(status);
				}
			}
		}
	}
	if (resultOop == 0) {

		/* It shouldn't be possible to get here */
		primitiveFail();
	}
	else {
		popthenPush(3, resultOop);
	}
	return 0;
}


/*	Answer an array of file attributes.
	primFileAttributes: aString mask: attributeMask
	aString is the path to the file
	attributeMask indicates which attributes to retrieve:
	bit 0 - get stat() attributes
	bit 1 - get access() attributes
	bit 2 - use lstat() instead of stat()
	On error answer the appropriate error code (Integer) */

	/* FileAttributesPlugin>>#primitiveFileAttributes */
EXPORT(sqInt)
primitiveFileAttributes(void)
{
    sqInt attributeArray;
    sqInt attributeMask;
    char cPathName[PATH_MAX];
    sqInt fileName;
    int status;
    sqInt val;

	attributeArray = 0;
	val = 0;
	fileName = stackObjectValue(1);
	attributeMask = stackIntegerValue(0);
	if ((failed())
	 || (!(isKindOf(fileName, "String")))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	status = pathOoptoBuffermaxLen(fileName, cPathName, PATH_MAX);
	if (status != 0) {
		return primitiveFailForOSError(status);
	}
	status = fileToAttributeArraymaskarray(cPathName, attributeMask, (&attributeArray));
	if (status != 0) {
		primitiveFailForOSError(status);
	}
	else {
		popthenPush(3, attributeArray);
	}
	return 0;
}


/*	Check for existence of a file with a call to access(). */

	/* FileAttributesPlugin>>#primitiveFileExists */
EXPORT(sqInt)
primitiveFileExists(void)
{
    sqInt accessFlag;
    char cString[PATH_MAX];
    sqInt len;
    sqInt mode;
    sqInt pathString;
    char *sPtr;
    sqInt status;

	accessFlag = 0;
	pathString = stackObjectValue(0);
	if (!(isKindOf(pathString, "String"))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	/* begin checkAccess:mode:to: */
	mode = F_OK;

	/* Note: The static sized string buffer is faster than using a Smalltalk allocated
	   string as the buffer, and is unlikely to fail in practice. In the event that
	   the buffer turns out to be too small, write an error message to stdout before
	   failing. */
	len = stSizeOf(pathString);
	if (len >= PATH_MAX) {
		status = -1 /* stringTooLong */;
		goto l1;
	}
	sPtr = arrayValueOf(pathString);
	if ((canStatFilePathlength(sPtr, len)) == 0) {
		/* begin cantStatPath */
		status = -3;
		goto l1;
	}
	memcpy(cString, sPtr, len);
	cString[len] = 0;
	((&accessFlag))[0] = (access(cString, mode));
	status = 0;
	l1:	/* end checkAccess:mode:to: */;
	if (!(status == 0)) {
		return primitiveFailForOSError(status);
	}
	popthenPush(2, (accessFlag == 0
		? trueObject()
		: falseObject()));
	return 0;
}


/*	Answer an array of well known file masks */

	/* FileAttributesPlugin>>#primitiveFileMasks */
EXPORT(sqInt)
primitiveFileMasks(void)
{
    sqInt masks;

	masks = instantiateClassindexableSize(classArray(), 8);
	if (!(masks)) {
		return primitiveFailFor(PrimErrNoMemory);
	}
	storePointerofObjectwithValue(0, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFMT)
		: positive32BitIntegerFor(S_IFMT)));
	
#  if !(defined(WIN32))
	storePointerofObjectwithValue(1, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFSOCK)
		: positive32BitIntegerFor(S_IFSOCK)));
	storePointerofObjectwithValue(2, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFLNK)
		: positive32BitIntegerFor(S_IFLNK)));
#  endif /* !(defined(WIN32)) */
	storePointerofObjectwithValue(3, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFREG)
		: positive32BitIntegerFor(S_IFREG)));
	storePointerofObjectwithValue(4, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFBLK)
		: positive32BitIntegerFor(S_IFBLK)));
	storePointerofObjectwithValue(5, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFDIR)
		: positive32BitIntegerFor(S_IFDIR)));
	storePointerofObjectwithValue(6, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFCHR)
		: positive32BitIntegerFor(S_IFCHR)));
	storePointerofObjectwithValue(7, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFIFO)
		: positive32BitIntegerFor(S_IFIFO)));
	popthenPush(1, masks);
	return 0;
}


/*	Answer the logical drive mask on windows */

	/* FileAttributesPlugin>>#primitiveLogicalDrives */
EXPORT(sqInt)
primitiveLogicalDrives(void)
{
    unsigned int mask;

	
#  if defined(WIN32)
	mask = GetLogicalDrives();
	if (mask != 0) {
		return popthenPush(1, positive32BitIntegerFor(mask));
	}
#  endif /* defined(WIN32) */
	primitiveFail();
	return 0;
}


/*	self primOpendir: '/etc' */

	/* FileAttributesPlugin>>#primitiveOpendir */
EXPORT(sqInt)
primitiveOpendir(void)
{
    osdir *dir;
    sqInt dirName;
    sqInt dirOop;
    int status;

	dirName = stackObjectValue(0);
	if (!(isKindOf(dirName, "String"))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	status = openDirectoryStreamptr(dirName, (&dir));
	if (status != 0) {
		return primitiveFailForOSError(status);
	}
	dirOop = addressObjectFor(dir);
	popthenPush(2, dirOop);
	return 0;
}


/*	Answer the value of PATH_MAX for the current VM */

	/* FileAttributesPlugin>>#primitivePathMax */
EXPORT(sqInt)
primitivePathMax(void)
{
	return popthenPush(1, integerObjectOf(PATH_MAX));
}


/*	Get the next entry in the directory stream. Answer the name of the entry,
	or nil for the end of the directory stream. */

	/* FileAttributesPlugin>>#primitiveReaddir */
EXPORT(sqInt)
primitiveReaddir(void)
{
    sqInt attributeArray;
    sqInt dirPointerOop;
    osdir *dirStream;
    struct dirent *ent;
    sqInt entryName;
    sqInt entry_len;
    int haveEntry;
    sqInt resultArray;
    sqInt status;
    sqInt val;

	attributeArray = 0;
	entryName = 0;
	val = 0;
	dirPointerOop = stackValue(0);
	dirStream = pointerFrom(dirPointerOop);
	if (!(dirStream)) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	haveEntry = 0;
	do {
		ent = readdir((dirStream->dp));
		if (ent == NULL ||
                 		((! (ent->d_name[0] == '.' && strlen(ent->d_name) == 1)) && strcmp(ent->d_name, "..")))
                     		haveEntry = 1;
	} while(haveEntry == 0);
	if (!(ent)) {

		/* This is the normal case for the end of a directory stream,
		   although it may indicate other error conditions for which errno would be updated.
		   Assume the normal case here. */
		return popthenPush(2, nilObject());
	}
	status = byteArrayFromCStringto((ent->d_name), (&entryName));
	if (status != 0) {
		return primitiveFailForOSError(status);
	}
	entry_len = strlen((ent->d_name));
	if ((((dirStream->path_len)) + entry_len) > (PATH_MAX - 1)) {
		return primitiveFailForOSError(-1 /* stringTooLong */);
	}
	memcpy((dirStream->path_file), (ent->d_name), entry_len);
	((dirStream->path_file))[entry_len] = 0;

	/* If the stat() fails, still return the filename, just no attributes */
	status = fileToAttributeArraymaskarray((dirStream->path), 1, (&attributeArray));
	if (status != 0) {
		attributeArray = nilObject();
	}
	
#if SPURVM
	resultArray = instantiateClassindexableSize(classArray(), 2);

#else /* SPURVM */
	pushRemappableOop(entryName);
	pushRemappableOop(attributeArray);
	resultArray = instantiateClassindexableSize(classArray(), 2);
	attributeArray = popRemappableOop();
	entryName = popRemappableOop()
#endif /* SPURVM */
;
	if (!(resultArray)) {
		return primitiveFailFor(PrimErrNoMemory);
	}
	storePointerofObjectwithValue(0, resultArray, entryName);
	storePointerofObjectwithValue(1, resultArray, attributeArray);
	popthenPush(2, resultArray);
	return 0;
}


/*	Set directoryStream to first entry. Answer dirPointerOop. */

	/* FileAttributesPlugin>>#primitiveRewinddir */
EXPORT(sqInt)
primitiveRewinddir(void)
{
    sqInt dirPointerOop;
    osdir *dirStream;

	dirPointerOop = stackValue(0);
	dirStream = pointerFrom(dirPointerOop);
	if (!(dirStream)) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	rewinddir((dirStream->dp));
	popthenPush(2, dirPointerOop);
	return 0;
}


/*	Answer a string containing the version string for this plugin. */

	/* FileAttributesPlugin>>#primitiveVersionString */
EXPORT(sqInt)
primitiveVersionString(void)
{
	popthenPush(1, stringFromCString("1.2.3"));
	return 0;
}


/*	Call stat() on cPathName, storing the results in
	the buffer at statBufPointer. */

	/* FileAttributesPlugin>>#putLStatFor:intoBuffer:targetName: */
static sqInt
putLStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop)
{
    char cLinkName[PATH_MAX];
    sqInt len;
    sqInt status;

	
#  if HAVE_LSTAT == 1
	status = lstat(cPathName, statBufPointer);
	if (status != 0) {
		/* begin cantStatPath */
		return -3;
	}
	if ((S_ISLNK((statBufPointer->st_mode))) == 0) {
		fileNameOop[0] = (nilObject());
	}
	else {
		len = readLinkintomaxLength(cPathName, cLinkName, PATH_MAX);
		if (len < 0) {
			return len;
		}
		status = byteArrayFromCStringto(cLinkName, fileNameOop);
	}
#  else /* HAVE_LSTAT == 1 */

	/* #HAVE_LSTAT = 1 */
	/* begin invalidRequest */
	status = -11;
#  endif /* HAVE_LSTAT == 1 */
	return status;
}


/*	Call stat() on cPathName, storing the results in
	the buffer at statBufPointer. */

	/* FileAttributesPlugin>>#putStatFor:intoBuffer:targetName: */
static sqInt
putStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop)
{
    sqInt status;

	status = stat(cPathName, statBufPointer);
	if (status != 0) {
		/* begin cantStatPath */
		return -3;
	}
	
#  if defined(WIN32)
	offsetStatBufTimesForWIN32(statBufPointer);
#  endif /* defined(WIN32) */
	fileNameOop[0] = (nilObject());
	return 0;
}


/*	Get the target filename of the supplied symbolic link. */

	/* FileAttributesPlugin>>#readLink:into:maxLength: */
static sqInt
readLinkintomaxLength(char *cPathName, char *cLinkPtr, size_t maxLength)
{
    sqInt len;


	/* len must be signed so that -1 can be communicated as an error. */
	len = 
#  if defined(WIN32)
		-1
#  else /* defined(WIN32) */
		readlink(cPathName, cLinkPtr, maxLength)
#  endif /* defined(WIN32) */
		;
	if (len < 0) {
		
#    if defined(INDEBUG)
		fprintf(stderr, "FileAttributesPlugin: unable to readlink(): %d, errno=%d\n", len, errno);
#    endif /* defined(INDEBUG) */
		/* begin cantReadlink */
		return -8;
	}
	cLinkPtr[len] = 0;
	return len;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine*anInterpreter)
{
    sqInt ok;

	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		arrayValueOf = interpreterProxy->arrayValueOf;
		classArray = interpreterProxy->classArray;
		classByteArray = interpreterProxy->classByteArray;
		classString = interpreterProxy->classString;
		failed = interpreterProxy->failed;
		falseObject = interpreterProxy->falseObject;
		instantiateClassindexableSize = interpreterProxy->instantiateClassindexableSize;
		integerObjectOf = interpreterProxy->integerObjectOf;
		ioLoadFunctionFrom = interpreterProxy->ioLoadFunctionFrom;
		isKindOf = interpreterProxy->isKindOf;
		nilObject = interpreterProxy->nilObject;
		popthenPush = interpreterProxy->popthenPush;
		popRemappableOop = interpreterProxy->popRemappableOop;
		positive32BitIntegerFor = interpreterProxy->positive32BitIntegerFor;
		positive64BitIntegerFor = interpreterProxy->positive64BitIntegerFor;
		primitiveFail = interpreterProxy->primitiveFail;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		primitiveFailForOSError = interpreterProxy->primitiveFailForOSError;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		signed32BitIntegerFor = interpreterProxy->signed32BitIntegerFor;
		signed64BitIntegerFor = interpreterProxy->signed64BitIntegerFor;
		sizeOfSTArrayFromCPrimitive = interpreterProxy->sizeOfSTArrayFromCPrimitive;
		stSizeOf = interpreterProxy->stSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackObjectValue = interpreterProxy->stackObjectValue;
		stackValue = interpreterProxy->stackValue;
		storePointerofObjectwithValue = interpreterProxy->storePointerofObjectwithValue;
		trueObject = interpreterProxy->trueObject;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}


/*	Answer a file entry array from the supplied statBufPointer */

	/* FileAttributesPlugin>>#statArrayFor:toArray:from:fileName: */
static sqInt
statArrayFortoArrayfromfileName(char *cPathName, sqInt attributeArray, struct stat *statBufPointer, sqInt fileNameOop)
{
    time_t creationDate;
    sqInt sizeIfFile;
    sqInt status;
    sqInt val;

	val = 0;
	sizeIfFile = ((S_ISDIR((statBufPointer->st_mode))) == 0
		? (statBufPointer->st_size)
		: 0);
	storePointerofObjectwithValue(0, attributeArray, fileNameOop);
	storePointerofObjectwithValue(1, attributeArray, (BytesPerWord == 8
		? positive64BitIntegerFor((statBufPointer->st_mode))
		: positive32BitIntegerFor((statBufPointer->st_mode))));
	storePointerofObjectwithValue(2, attributeArray, positive64BitIntegerFor((statBufPointer->st_ino)));
	storePointerofObjectwithValue(3, attributeArray, positive64BitIntegerFor((statBufPointer->st_dev)));
	storePointerofObjectwithValue(4, attributeArray, positive64BitIntegerFor((statBufPointer->st_nlink)));
	storePointerofObjectwithValue(5, attributeArray, (BytesPerWord == 8
		? positive64BitIntegerFor((statBufPointer->st_uid))
		: positive32BitIntegerFor((statBufPointer->st_uid))));
	storePointerofObjectwithValue(6, attributeArray, (BytesPerWord == 8
		? positive64BitIntegerFor((statBufPointer->st_gid))
		: positive32BitIntegerFor((statBufPointer->st_gid))));
	storePointerofObjectwithValue(7, attributeArray, positive64BitIntegerFor(sizeIfFile));
	storePointerofObjectwithValue(8, attributeArray, oopFromTimeT((statBufPointer->st_atime)));
	storePointerofObjectwithValue(9, attributeArray, oopFromTimeT((statBufPointer->st_mtime)));
	storePointerofObjectwithValue(10, attributeArray, oopFromTimeT((statBufPointer->st_ctime)));
	
#  if defined(WIN32)
	status = fileCreationTimeForlengthto(cPathName, strlen(cPathName), (&creationDate));
	storePointerofObjectwithValue(11, attributeArray, (status == 0
		? (/* begin oopFromTimeT: */
			((sizeof(time_t)) == 4
					? (signed32BitIntegerFor(creationDate),
						goto l1)
					: 0),
			signed64BitIntegerFor(creationDate),
	l1:	/* end oopFromTimeT: */)
		: nilObject()));
#  else /* defined(WIN32) */
	storePointerofObjectwithValue(11, attributeArray, nilObject());
#  endif /* defined(WIN32) */
	return 0;
}


/*	Answer a new String copied from a null-terminated C string.
	Caution: This may invoke the garbage collector. */

	/* FileAttributesPlugin>>#stringFromCString: */
static sqInt
stringFromCString(const char *aCString)
{
    sqInt len;
    sqInt newString;

	len = strlen(aCString);
	newString = instantiateClassindexableSize(classString(), len);
	if (!(newString)) {
		return primitiveFailFor(PrimErrNoMemory);
	}
	strncpy(arrayValueOf(newString), aCString, len);
	return newString;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "FileAttributesPlugin";
void* FileAttributesPlugin_exports[][3] = {
	{(void*)_m, "checkAccessmodeto", (void*)checkAccessmodeto},
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "initialiseModule", (void*)initialiseModule},
	{(void*)_m, "primitiveClosedir\000\001", (void*)primitiveClosedir},
	{(void*)_m, "primitiveFileAttribute\000\001", (void*)primitiveFileAttribute},
	{(void*)_m, "primitiveFileAttributes\000\001", (void*)primitiveFileAttributes},
	{(void*)_m, "primitiveFileExists\000\001", (void*)primitiveFileExists},
	{(void*)_m, "primitiveFileMasks\000\377", (void*)primitiveFileMasks},
	{(void*)_m, "primitiveLogicalDrives\000\377", (void*)primitiveLogicalDrives},
	{(void*)_m, "primitiveOpendir\000\002", (void*)primitiveOpendir},
	{(void*)_m, "primitivePathMax\000\377", (void*)primitivePathMax},
	{(void*)_m, "primitiveReaddir\000\001", (void*)primitiveReaddir},
	{(void*)_m, "primitiveRewinddir\000\001", (void*)primitiveRewinddir},
	{(void*)_m, "primitiveVersionString\000\377", (void*)primitiveVersionString},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

signed char primitiveClosedirAccessorDepth = 1;
signed char primitiveFileAttributeAccessorDepth = 1;
signed char primitiveFileAttributesAccessorDepth = 1;
signed char primitiveFileExistsAccessorDepth = 1;
signed char primitiveOpendirAccessorDepth = 2;
signed char primitiveReaddirAccessorDepth = 1;
signed char primitiveRewinddirAccessorDepth = 1;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
