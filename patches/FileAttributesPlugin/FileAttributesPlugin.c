/* Smalltalk from Squeak5.1 with VMMaker 4.16.3 translated as C source on 4 June 2017 7:09:56 pm */
/* Automatically generated by
	VMPluginCodeGenerator VMMaker-dtl.392 uuid: 7c31d31d-9de0-4f45-89e2-6caa1886f12f
   from
	FileAttributesPlugin * FileAttributesPlugin-AlistairGrant.8 uuid: a7a85b1f-081b-4c11-b2e1-70b0bfa11f37
 */
static char __buildInfo[] = "FileAttributesPlugin * FileAttributesPlugin-AlistairGrant.8 uuid: a7a85b1f-081b-4c11-b2e1-70b0bfa11f37 " __DATE__ ;




#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
/*  The virtual machine proxy definition */
#include "sqVirtualMachine.h"
/* Configuration options */
#include "sqConfig.h"
/* Platform specific definitions */
#include "sqPlatformSpecific.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
#undef EXPORT
// was #undef EXPORT(returnType) but screws NorCroft cc
#define EXPORT(returnType) static returnType
#endif
#include <sys/types.h>
#include <dirent.h>
#ifdef WIN32
#include <windows.h>
#include <winbase.h>
#define FAIL() { return -1; }
#include "sqWin32File.h"
#endif
typedef struct dirptrstruct {
    		DIR *dp;
		int path_len;
    		char *path_file;
   		char path[PATH_MAX+4];
    		} osdir;
#include <sys/stat.h>
#if !defined(HAVE_LSTAT) && !defined(WIN32)
#define HAVE_LSTAT 1
#endif
#include <unistd.h>
/* AKG 2017 - FileAttributesPlugin.c translated from class FileAttributesPlugin */

#include "sqMemoryAccess.h"


/*** Constants ***/

/*** Function Prototypes ***/
static sqInt accessAttributesForFilenameintostartingAt(char *cPathName, sqInt attributeArray, sqInt offset);
static sqInt addressObjectFor(void *aMachineAddress);
static sqInt byteArrayFromCStringto(const char *aCString, sqInt *byteArrayOop);
static sqInt canOpenDirectoryStreamForlength(char *aPathCString, sqInt length);
static sqInt canStatFilePathlength(char *aPathCString, sqInt length);
#pragma export on
EXPORT(sqInt) checkAccessmodeto(sqInt pathString, sqInt mode, sqInt *flag);
#pragma export off
static sqInt fileCreationTimeForlengthto(char *pathString, sqInt pathLength, time_t *creationDate);
static sqInt fileExecutableFlag(void);
static sqInt fileOKFlag(void);
static sqInt fileReadableFlag(void);
static int fileToAttributeArraymaskarray(char *cPathName, sqInt attributeMask, sqInt *attributeArray);
static sqInt fileWriteableFlag(void);
#pragma export on
EXPORT(const char*) getModuleName(void);
#pragma export off
static sqInt halt(void);
static sqInt isSymlinkboolean(char *cPathName, sqInt *resultOop);
static sqInt oopFromTimeT(time_t posixSeconds);
static int openDirectoryStreamptr(sqInt pathOOP, osdir **osdirPtr);
static int pathOoptoBuffermaxLen(sqInt pathNameOop, char *cPathName, sqInt maxLen);
static void * pointerFrom(sqInt directoryPointerBytes);
#pragma export on
EXPORT(sqInt) primitiveClosedir(void);
EXPORT(sqInt) primitiveFileAttribute(void);
EXPORT(sqInt) primitiveFileAttributes(void);
EXPORT(sqInt) primitiveFileExists(void);
EXPORT(sqInt) primitiveFileMasks(void);
EXPORT(sqInt) primitiveLogicalDrives(void);
EXPORT(sqInt) primitiveOpendir(void);
EXPORT(sqInt) primitivePathMax(void);
EXPORT(sqInt) primitiveReaddir(void);
EXPORT(sqInt) primitiveRewinddir(void);
EXPORT(sqInt) primitiveVersionString(void);
#pragma export off
static sqInt putLStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop);
static sqInt putStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop);
static size_t readLinkintomaxLength(char *cPathName, char *cLinkPtr, size_t maxLength);
#pragma export on
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
#pragma export off
static sqInt sizeOfPointer(void);
static sqInt smallOrLargeIntegerObjectFor(sqInt aPositiveInteger);
static sqInt statArrayFortoArrayfromfileName(char *cPathName, sqInt attributeArray, struct stat *statBufPointer, sqInt fileNameOop);
static sqInt stringFromCString(const char *aCString);
static char * versionString(void);
static sqInt wrappedErrorCode(sqInt aNumber);
/*** Variables ***/
static int hasSecurityPlugin= 1;

#ifdef SQUEAK_BUILTIN_PLUGIN
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"FileAttributesPlugin 4 June 2017 (i)"
#else
	"FileAttributesPlugin 4 June 2017 (e)"
#endif
;
static int smallIntegerMaxVal= 1073741823;



/*	Call access() for each access type (R, W, X) on the c string cPathName, storing the results in the st array attributeArray. */

static sqInt accessAttributesForFilenameintostartingAt(char *cPathName, sqInt attributeArray, sqInt offset) {
    sqInt boolean;
    sqInt index;

	index = offset;
	if ((access(cPathName, R_OK)) == 0) {
		boolean = interpreterProxy->trueObject();
	} else {
		boolean = interpreterProxy->falseObject();
	}
	interpreterProxy->storePointerofObjectwithValue(index, attributeArray, boolean);
	index += 1;
	if ((access(cPathName, W_OK)) == 0) {
		boolean = interpreterProxy->trueObject();
	} else {
		boolean = interpreterProxy->falseObject();
	}
	interpreterProxy->storePointerofObjectwithValue(index, attributeArray, boolean);
	index += 1;
	if ((access(cPathName, X_OK)) == 0) {
		boolean = interpreterProxy->trueObject();
	} else {
		boolean = interpreterProxy->falseObject();
	}
	interpreterProxy->storePointerofObjectwithValue(index, attributeArray, boolean);
	return null;
}


/*	Answer an ExternalAddress object which represents aMachineAddress */

static sqInt addressObjectFor(void *aMachineAddress) {
    sqInt addressOop;
    unsigned char *addressOopArrayPointer;
    union {void *address; unsigned char bytes[sizeof(void *)];} addressUnion;
    sqInt idx;

	addressOop = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classByteArray(), sizeOfPointer());
	addressOopArrayPointer = interpreterProxy->arrayValueOf(addressOop);
	addressUnion.address = aMachineAddress;
	idx = 0;
	while (idx < (sizeOfPointer())) {
		addressOopArrayPointer[idx] = addressUnion.bytes[idx];
		idx += 1;
	}
	return addressOop;
}


/*	Answer a new ByteArray copied from a null-terminated C string.
	Caution: This may invoke the garbage collector. */

static sqInt byteArrayFromCStringto(const char *aCString, sqInt *byteArrayOop) {
    unsigned char *byteArrayPtr;
    sqInt len;
    sqInt newByteArray;


	/* We never return strings longer than PATH_MAX */

	len = strlen(aCString);
	if (len > (PATH_MAX)) {
		return -1;
	}
	newByteArray = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classByteArray(), len);
	byteArrayPtr = interpreterProxy->arrayValueOf(newByteArray);
	memcpy(byteArrayPtr, aCString, len);
	*byteArrayOop = newByteArray;
	return 0;
}


/*	Answer non-zero if security permits the directory to be listed. */
/*	FIXME: This function has not been tested. -dtl */

static sqInt canOpenDirectoryStreamForlength(char *aPathCString, sqInt length) {
    void *sCLPfn;


	/* If the security plugin can be loaded, use it to check . 
	If not, assume it's ok */
	/* The hasSecurityPlugin flag is set to 1 by default */

	if (hasSecurityPlugin == 0) {
		return 1;
	}
	sCLPfn = interpreterProxy->ioLoadFunctionFrom("secCanListPathOfSize", "SecurityPlugin");
	if (sCLPfn != 0) {
		return  ((int (*) (char *, int)) sCLPfn)(aPathCString, length);
	} else {

		/* Reset the flag so we do not try again next time */

		hasSecurityPlugin = 0;
		return 1;
	}
	return null;
}


/*	Answer non-zero if security permits the a stat() call on the file path. Allow a
	stat() call only on files which we are permitted to open. */
/*	FIXME: This function has not been tested. -dtl */

static sqInt canStatFilePathlength(char *aPathCString, sqInt length) {
    void *sCOFfn;


	/* If the security plugin can be loaded, use it to check . 
	If not, assume it's ok */
	/* The hasSecurityPlugin flag is set to 1 by default */

	if (hasSecurityPlugin == 0) {
		return 1;
	}
	sCOFfn = interpreterProxy->ioLoadFunctionFrom("secCanOpenFileOfSizeWritable", "SecurityPlugin");
	if (sCOFfn != 0) {
		return  ((int (*) (char *, int, int)) sCOFfn)(aPathCString, length, 0);
	} else {

		/* Reset the flag so we do not try again next time */

		hasSecurityPlugin = 0;
		return 1;
	}
	return null;
}


/*	Check access to pathString. */

EXPORT(sqInt) checkAccessmodeto(sqInt pathString, sqInt mode, sqInt *flag) {
    char cString[PATH_MAX];
    sqInt len;
    char *sPtr;


	/* Note: The static sized string buffer is faster than using a Smalltalk allocated
	string as the buffer, and is unlikely to fail in practice. In the event that
	the buffer turns out to be too small, write an error message to stdout before
	failing. */

	len = interpreterProxy->stSizeOf(pathString);
	if (len >= (PATH_MAX)) {
		return -1;
	}
	sPtr = interpreterProxy->arrayValueOf(pathString);
	if ((canStatFilePathlength(sPtr, len)) == 0) {
		return -3;
	}
	memcpy(cString, sPtr, len);
	cString[len] = 0;
	*flag = access(cString, mode);
	return 0;
}


/*	Get the creationDate for the supplied file.
	Linux kernel 4.11 should have statx(), so hopefully there will be a cross-platform
	solution soon.  Just dump the c-code and hope to remove it soon. */

static sqInt fileCreationTimeForlengthto(char *pathString, sqInt pathLength, time_t *creationDate) {
    struct tm tm;

	
#ifdef WIN32
  WIN32_FILE_ATTRIBUTE_DATA winAttrs;
  WCHAR *win32Path;
  SYSTEMTIME sysTime;
#endif

  memset(&tm, 0, sizeof(tm));

#ifdef WIN32
  /* convert the supplied path name into a wide string */
  ALLOC_WIN32_PATH(win32Path, pathString, pathLength);
	if ((GetFileAttributesExW(win32Path, 0, &winAttrs)) == 0) {
		return -4;
	}
	if ((FileTimeToSystemTime(&winAttrs.ftCreationTime, &sysTime)) == 0) {
		return -5;
	}
	
  tm.tm_year = sysTime.wYear - 1900;
  tm.tm_mon = sysTime.wMonth - 1;
  tm.tm_mday = sysTime.wDay;

  tm.tm_hour = sysTime.wHour;
  tm.tm_min = sysTime.wMinute;
  tm.tm_sec = sysTime.wSecond;
  tm.tm_isdst = 0;
#endif

  *creationDate = mktime(&tm);
	return 0;
}

static sqInt fileExecutableFlag(void) {
	return X_OK;
}

static sqInt fileOKFlag(void) {
	return F_OK;
}

static sqInt fileReadableFlag(void) {
	return R_OK;
}


/*	Answer a file attribute array from pathNameOop. */

static int fileToAttributeArraymaskarray(char *cPathName, sqInt attributeMask, sqInt *attributeArray) {
    sqInt accessArray;
    sqInt combinedArray;
    sqInt fileNameOop;
    sqInt getAccess;
    sqInt getStats;
    sqInt statArray;
    struct stat statBuf;
    struct stat *statBufPointer= &statBuf;
    sqInt status;
    sqInt useLstat;


	/* Determine which attributes to retrieve */

	getStats = (attributeMask & 1) == 1;
	getAccess = (attributeMask & 2) == 2;
	if (!(getStats || (getAccess))) {

		/* No information has been requested, which doesn't make sense */

		return -6;
	}
	if (getStats) {
		useLstat = (attributeMask & 4) == 4;
		statArray = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classArray(), 12);
		if (useLstat) {
			status = putLStatForintoBuffertargetName(cPathName, statBufPointer, &fileNameOop);
		} else {
			status = putStatForintoBuffertargetName(cPathName, statBufPointer, &fileNameOop);
		}
		if (status != 0) {
			return status;
		}
		status = statArrayFortoArrayfromfileName(cPathName, statArray, statBufPointer, fileNameOop);
		if (status != 0) {
			return status;
		}
		*attributeArray = statArray;
	}
	if (getAccess) {
		accessArray = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classArray(), 3);
		accessAttributesForFilenameintostartingAt(cPathName, accessArray, 0);
		*attributeArray = accessArray;
	}
	if (getStats && (getAccess)) {
		combinedArray = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classArray(), 2);
		*attributeArray = combinedArray;
		interpreterProxy->storePointerofObjectwithValue(0, combinedArray, statArray);
		interpreterProxy->storePointerofObjectwithValue(1, combinedArray, accessArray);
	}
	return 0;
}

static sqInt fileWriteableFlag(void) {
	return W_OK;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

EXPORT(const char*) getModuleName(void) {
	return moduleName;
}

static sqInt halt(void) {
	;
	return null;
}


/*	Set resultOop to a boolean indicating whether cPathName is a symbolic link.
	Answer status (0 = success) */

static sqInt isSymlinkboolean(char *cPathName, sqInt *resultOop) {
    struct stat statBuf;
    sqInt status;

	
# if (HAVE_LSTAT == 1)  // 
	status = lstat(cPathName, &statBuf);
	if (status != 0) {
		return -3;
	}
	if ((S_ISLNK(statBuf.st_mode)) == 0) {
		*resultOop = interpreterProxy->falseObject();
	} else {
		*resultOop = interpreterProxy->trueObject();
	}
# endif  // HAVE_LSTAT == 1
	
	return 0;
}


/*	Answer an object representation of the provided time (time_t).
	The size of time_t is platform dependent, so check the size and convert appropriately. */

static sqInt oopFromTimeT(time_t posixSeconds) {
	if ((sizeof(time_t)) == 4) {
		return interpreterProxy->signed32BitIntegerFor(posixSeconds);
	}
	return interpreterProxy->signed64BitIntegerFor(posixSeconds);
}


/*	Open a new directory stream. Answer a pointer to the directory stream or NULL. */

static int openDirectoryStreamptr(sqInt pathOOP, osdir **osdirPtr) {
    osdir *dir;
    sqInt len;
    char *sPtr;

	sPtr = interpreterProxy->arrayValueOf(pathOOP);

	/* The path buffer needs room for a trailing slash and the file name, so subtracting 2 is conservative */

	len = interpreterProxy->sizeOfSTArrayFromCPrimitive(sPtr);
	if (len > (PATH_MAX-2)) {
		return -1;
	}
	if (canOpenDirectoryStreamForlength(sPtr, len)) {
		dir = (osdir *) malloc(sizeof(osdir));
		if (dir == null) {
			return -10;
		}
		memcpy(dir->path, sPtr, len);
		if (dir->path[len-1] != '/') {
				dir->path[len++] = '/';
				}
		dir->path_file = dir->path + len;
		dir->path_file[0] = '\0';
		dir->path_len = len;
		dir->dp =  opendir(dir->path);
		if ((dir->dp) == null) {
			free(dir);
			return -9;
		}
		*osdirPtr = dir;
		return 0;
	}
	return -9;
}


/*	Copy the supplied path name string object to the supplied c string buffer */

static int pathOoptoBuffermaxLen(sqInt pathNameOop, char *cPathName, sqInt maxLen) {
    sqInt len;
    char *sPtr;

	len = interpreterProxy->stSizeOf(pathNameOop);
	if (len >= maxLen) {
		return -1;
	}
	sPtr = interpreterProxy->arrayValueOf(pathNameOop);
	if ((canStatFilePathlength(sPtr, len)) == 0) {
		return -3;
	}
	memcpy(cPathName, sPtr, len);
	cPathName[len] = 0;
	return 0;
}


/*	Answer the machine address contained in anExternalAddressOop. */

static void * pointerFrom(sqInt directoryPointerBytes) {
    union {void *address; unsigned char bytes[sizeof(void *)];} addressUnion;
    sqInt idx;
    unsigned char *ptr;

	if (!((interpreterProxy->isBytes(directoryPointerBytes)) && ((interpreterProxy->stSizeOf(directoryPointerBytes)) == (sizeOfPointer())))) {
		return null;
	}
	ptr = interpreterProxy->arrayValueOf(directoryPointerBytes);
	idx = 0;
	while (idx < (sizeOfPointer())) {
		addressUnion.bytes[idx] = ptr[idx];
		idx += 1;
	}
	return addressUnion.address;
}


/*	Close the directory stream for dirPointerOop. Answer dirPointerOop on success. */

EXPORT(sqInt) primitiveClosedir(void) {
    sqInt dirPointerOop;
    osdir *dirStream;
    sqInt result;

	dirPointerOop = interpreterProxy->stackObjectValue(0);
	if (dirPointerOop == (interpreterProxy->nilObject())) {
		return interpreterProxy->pop(2),interpreterProxy->push(interpreterProxy->signed32BitIntegerFor(-6));
	}
	if (!(interpreterProxy->isKindOf(dirPointerOop, "ByteArray"))) {
		fprintf(stderr, "primitiveClosedir: invalid argument, expected an ByteArray\n");
		return interpreterProxy->pop(2),interpreterProxy->push(interpreterProxy->signed32BitIntegerFor(-6));
	}
	dirStream = pointerFrom(dirPointerOop);
	if (dirStream == null) {
		return interpreterProxy->pop(2),interpreterProxy->push(interpreterProxy->signed32BitIntegerFor(-7));
	}
	result = closedir(dirStream->dp);
	if (!(result == 0)) {
		perror("closedir");
		return interpreterProxy->pop(2),interpreterProxy->push(interpreterProxy->signed32BitIntegerFor(-7));
	}
	free(dirStream);
	interpreterProxy->pop(2);
	interpreterProxy->push(dirPointerOop);
	return null;
}


/*	Answer a single file attribute.
	primFileAttributes: aString attributeNumber: attributeNumber
	aString is the path to the file
	attributeNumber identifies which attribute to return:
	1 - 12: stat(): name, mode, ino, dev, nlink, uid, gid, size, accessDate, modifiedDate, changeDate, creationDate
	13 - 15: access(): R_OK, W_OK, X_OK
	16: isSymlink
	On error, answer a single element array containing the appropriate error code. */

EXPORT(sqInt) primitiveFileAttribute(void) {
    sqInt attributeNumber;
    char cPathName[PATH_MAX];
    time_t creationDate;
    sqInt fileName;
    sqInt fileNameOop;
    sqInt mode;
    sqInt resultOop;
    sqInt sizeIfFile;
    struct stat statBuf;
    struct stat *statBufPointer= &statBuf;
    sqInt status;

	fileName = interpreterProxy->stackObjectValue(1);
	attributeNumber = interpreterProxy->stackIntegerValue(0);
	if ((attributeNumber < 1) || (attributeNumber > 16)) {
		return interpreterProxy->pop(3),interpreterProxy->push(wrappedErrorCode(-6));
	}
	if (!(interpreterProxy->isKindOf(fileName, "String"))) {
		return interpreterProxy->pop(3),interpreterProxy->push(wrappedErrorCode(-6));
	}
	status = pathOoptoBuffermaxLen(fileName, cPathName, PATH_MAX);
	if (status != 0) {
		return interpreterProxy->pop(3),interpreterProxy->push(wrappedErrorCode(status));
	}
	resultOop = 0;
	if (attributeNumber < 12) {

		/* Get requested stat entry */

		status = putStatForintoBuffertargetName(cPathName, statBufPointer, &fileNameOop);
		if (status != 0) {
			return interpreterProxy->pop(3),interpreterProxy->push(wrappedErrorCode(status));
		}
		if (attributeNumber == 1) {
			resultOop = fileNameOop;
		}
		if (attributeNumber == 2) {
			/* begin smallOrLargeIntegerObjectFor: */
			if ((statBuf.st_mode) > smallIntegerMaxVal) {
				resultOop = (((statBuf.st_mode) << 1) | 1);
				goto l1;
			} else {
				resultOop = interpreterProxy->positive32BitIntegerFor(statBuf.st_mode);
				goto l1;
			}
		l1:	/* end smallOrLargeIntegerObjectFor: */;
		}
		if (attributeNumber == 3) {
			resultOop = interpreterProxy->positive64BitIntegerFor(statBuf.st_ino);
		}
		if (attributeNumber == 4) {
			resultOop = interpreterProxy->positive64BitIntegerFor(statBuf.st_dev);
		}
		if (attributeNumber == 5) {
			resultOop = interpreterProxy->positive64BitIntegerFor(statBuf.st_nlink);
		}
		if (attributeNumber == 6) {
			/* begin smallOrLargeIntegerObjectFor: */
			if ((statBuf.st_uid) > smallIntegerMaxVal) {
				resultOop = (((statBuf.st_uid) << 1) | 1);
				goto l2;
			} else {
				resultOop = interpreterProxy->positive32BitIntegerFor(statBuf.st_uid);
				goto l2;
			}
		l2:	/* end smallOrLargeIntegerObjectFor: */;
		}
		if (attributeNumber == 7) {
			/* begin smallOrLargeIntegerObjectFor: */
			if ((statBuf.st_gid) > smallIntegerMaxVal) {
				resultOop = (((statBuf.st_gid) << 1) | 1);
				goto l3;
			} else {
				resultOop = interpreterProxy->positive32BitIntegerFor(statBuf.st_gid);
				goto l3;
			}
		l3:	/* end smallOrLargeIntegerObjectFor: */;
		}
		if (attributeNumber == 8) {
			if ((S_ISDIR(statBuf.st_mode)) == 0) {
				sizeIfFile = statBuf.st_size;
			} else {
				sizeIfFile = 0;
			}
			/* begin smallOrLargeIntegerObjectFor: */
			if (sizeIfFile > smallIntegerMaxVal) {
				resultOop = ((sizeIfFile << 1) | 1);
				goto l4;
			} else {
				resultOop = interpreterProxy->positive32BitIntegerFor(sizeIfFile);
				goto l4;
			}
		l4:	/* end smallOrLargeIntegerObjectFor: */;
		}
		if (attributeNumber == 9) {
			resultOop = oopFromTimeT(statBuf.st_atime);
		}
		if (attributeNumber == 10) {
			resultOop = oopFromTimeT(statBuf.st_mtime);
		}
		if (attributeNumber == 11) {
			resultOop = oopFromTimeT(statBuf.st_ctime);
		}
	} else {
		if (attributeNumber == 12) {
			status = fileCreationTimeForlengthto(cPathName, strlen(cPathName), &creationDate);
			if (status != 0) {
				return interpreterProxy->pop(3),interpreterProxy->push(wrappedErrorCode(status));
			}
			resultOop = oopFromTimeT(creationDate);
		} else {
			if (attributeNumber < 16) {

				/* Get requested access entry */

				if (attributeNumber == 13) {
					mode = fileReadableFlag();
				}
				if (attributeNumber == 14) {
					mode = fileWriteableFlag();
				}
				if (attributeNumber == 15) {
					mode = fileExecutableFlag();
				}
				if ((access(cPathName, mode)) == 0) {
					resultOop = interpreterProxy->trueObject();
				} else {
					resultOop = interpreterProxy->falseObject();
				}
			} else {

				/* attributeNumber = 16 */

				status = isSymlinkboolean(cPathName, &resultOop);
				if (status != 0) {
					return interpreterProxy->pop(3),interpreterProxy->push(wrappedErrorCode(status));
				}
			}
		}
	}
	if (resultOop == 0) {

		/* It shouldn't be possible to get here */

		return interpreterProxy->primitiveFail();
	} else {
		interpreterProxy->pop(3);
		interpreterProxy->push(resultOop);
	}
	return null;
}


/*	Answer an array of file attributes.
	primFileAttributes: aString mask: attributeMask
	aString is the path to the file
	attributeMask indicates which attributes to retrieve:
	bit 0 - get stat() attributes
	bit 1 - get access() attributes
	bit 2 - use lstat() instead of stat()
	On error answer the appropriate error code (Integer) */

EXPORT(sqInt) primitiveFileAttributes(void) {
    sqInt attributeArray;
    sqInt attributeMask;
    char cPathName[PATH_MAX];
    sqInt fileName;
    sqInt status;

	fileName = interpreterProxy->stackObjectValue(1);
	attributeMask = interpreterProxy->stackIntegerValue(0);
	if (!(interpreterProxy->isKindOf(fileName, "String"))) {
		return interpreterProxy->pop(3),interpreterProxy->push(interpreterProxy->signed32BitIntegerFor(-6));
	}
	status = pathOoptoBuffermaxLen(fileName, cPathName, PATH_MAX);
	if (status != 0) {
		return interpreterProxy->pop(3),interpreterProxy->push(interpreterProxy->signed32BitIntegerFor(status));
	}
	status = fileToAttributeArraymaskarray(cPathName, attributeMask, &attributeArray);
	if (status != 0) {
		interpreterProxy->pop(3);
		interpreterProxy->push(interpreterProxy->signed32BitIntegerFor(status));
	} else {
		interpreterProxy->pop(3);
		interpreterProxy->push(attributeArray);
	}
	return null;
}


/*	Check for existence of a file with a call to access(). */

EXPORT(sqInt) primitiveFileExists(void) {
    sqInt accessFlag;
    sqInt pathString;
    sqInt status;

	pathString = interpreterProxy->stackObjectValue(0);
	if (!(interpreterProxy->isKindOf(pathString, "String"))) {
		return interpreterProxy->pop(2),interpreterProxy->push(interpreterProxy->signed32BitIntegerFor(-6));
	}
	status = checkAccessmodeto(pathString, fileOKFlag(), &accessFlag);
	if (!(status == 0)) {
		return interpreterProxy->pop(2),interpreterProxy->push(interpreterProxy->signed32BitIntegerFor(status));
	}
	if (accessFlag == 0) {
		interpreterProxy->pop(2);
		interpreterProxy->push(interpreterProxy->trueObject());
	} else {
		interpreterProxy->pop(2);
		interpreterProxy->push(interpreterProxy->falseObject());
	}
	return null;
}


/*	Answer an array of well known file masks */

EXPORT(sqInt) primitiveFileMasks(void) {
    sqInt masks;

	masks = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classArray(), 8);
	interpreterProxy->storePointerofObjectwithValue(0, masks, smallOrLargeIntegerObjectFor(S_IFMT));
	
# if (defined(WIN32))  // windows doesn't have SOCK or SYMLINK file types
	null;
# else
	interpreterProxy->storePointerofObjectwithValue(1, masks, smallOrLargeIntegerObjectFor(S_IFSOCK));
	interpreterProxy->storePointerofObjectwithValue(2, masks, smallOrLargeIntegerObjectFor(S_IFLNK));
# endif  // defined(WIN32)
	
	interpreterProxy->storePointerofObjectwithValue(3, masks, smallOrLargeIntegerObjectFor(S_IFREG));
	interpreterProxy->storePointerofObjectwithValue(4, masks, smallOrLargeIntegerObjectFor(S_IFBLK));
	interpreterProxy->storePointerofObjectwithValue(5, masks, smallOrLargeIntegerObjectFor(S_IFDIR));
	interpreterProxy->storePointerofObjectwithValue(6, masks, smallOrLargeIntegerObjectFor(S_IFCHR));
	interpreterProxy->storePointerofObjectwithValue(7, masks, smallOrLargeIntegerObjectFor(S_IFIFO));
	interpreterProxy->popthenPush(1, masks);
	return null;
}


/*	Answer the logical drive mask on windows */

EXPORT(sqInt) primitiveLogicalDrives(void) {
    sqInt mask;

	
# if (defined(WIN32))  // Answer the logical drive mask on windows
	mask = GetLogicalDrives();
	if (mask != 0) {
		return interpreterProxy->popthenPush(1, interpreterProxy->positive32BitIntegerFor(mask));
	}
# endif  // defined(WIN32)
	
	return interpreterProxy->primitiveFail();
}


/*	self primOpendir: '/etc' */

EXPORT(sqInt) primitiveOpendir(void) {
    osdir *dir;
    sqInt dirName;
    sqInt dirOop;
    sqInt status;

	dirName = interpreterProxy->stackObjectValue(0);
	if (!(interpreterProxy->isKindOf(dirName, "String"))) {
		fprintf(stderr, "primitiveOpendir: invalid argument, expected a String\n");
		return interpreterProxy->pop(2),interpreterProxy->push(interpreterProxy->signed32BitIntegerFor(-6));
	}
	status = openDirectoryStreamptr(dirName, &dir);
	if (status != 0) {
		return interpreterProxy->pop(2),interpreterProxy->push(interpreterProxy->signed32BitIntegerFor(status));
	}
	dirOop = addressObjectFor(dir);
	interpreterProxy->pop(2);
	interpreterProxy->push(dirOop);
	return null;
}


/*	Answer the value of PATH_MAX for the current VM */

EXPORT(sqInt) primitivePathMax(void) {
	return interpreterProxy->popthenPush(1, smallOrLargeIntegerObjectFor(PATH_MAX));
}


/*	Get the next entry in the directory stream. Answer the name of the entry, or
	error for end of directory stream. */

EXPORT(sqInt) primitiveReaddir(void) {
    sqInt attributeArray;
    sqInt dirPointerOop;
    osdir *dirStream;
    struct dirent *ent;
    sqInt entryName;
    sqInt entry_len;
    int haveEntry;
    sqInt resultArray;
    sqInt status;

	dirPointerOop = interpreterProxy->stackObjectValue(0);
	if (!(interpreterProxy->isKindOf(dirPointerOop, "ByteArray"))) {
		fprintf(stderr, "primitiveReaddir: invalid argument, expected an ByteArray\n");
		return interpreterProxy->pop(2),interpreterProxy->push(interpreterProxy->signed32BitIntegerFor(-6));
	}
	dirStream = pointerFrom(dirPointerOop);
	if (dirStream == null) {
		return interpreterProxy->pop(2),interpreterProxy->push(interpreterProxy->signed32BitIntegerFor(-6));
	}
	haveEntry = 0;
	do {;
	ent = readdir(dirStream->dp);
	if (ent == NULL ||
                 		((! (ent->d_name[0] == '.' && strlen(ent->d_name) == 1)) && strcmp(ent->d_name, "..")))
                     		haveEntry = 1;
		} while (haveEntry == 0);
	if (ent == null) {

		/* This is the normal case for the end of a directory stream,
		although it may indicate other error conditions for which errno would be updated.
		Assume the normal case here. */

		return interpreterProxy->pop(2),interpreterProxy->push(interpreterProxy->nilObject());
	}
	status = byteArrayFromCStringto(ent->d_name, &entryName);
	if (status != 0) {
		return interpreterProxy->pop(2),interpreterProxy->push(interpreterProxy->signed32BitIntegerFor(status));
	}
	entry_len = strlen(ent->d_name);
	if (((dirStream->path_len) + entry_len) > (PATH_MAX-1)) {
		return interpreterProxy->pop(2),interpreterProxy->push(interpreterProxy->signed32BitIntegerFor(-1));
	}
	memcpy(dirStream->path_file, ent->d_name, entry_len);
	dirStream->path_file[entry_len] = '\0';

	/* If the stat() fails, still return the filename, just no attributes */

	status = fileToAttributeArraymaskarray(dirStream->path, 1, &attributeArray);
	if (status != 0) {
		attributeArray = interpreterProxy->nilObject();
	}
	resultArray = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classArray(), 2);
	interpreterProxy->storePointerofObjectwithValue(0, resultArray, entryName);
	interpreterProxy->storePointerofObjectwithValue(1, resultArray, attributeArray);
	interpreterProxy->pop(2);
	interpreterProxy->push(resultArray);
	return null;
}


/*	Set directoryStream to first entry. Answer dirPointerOop. */

EXPORT(sqInt) primitiveRewinddir(void) {
    sqInt dirPointerOop;
    osdir *dirStream;

	dirPointerOop = interpreterProxy->stackObjectValue(0);
	if (!(interpreterProxy->isKindOf(dirPointerOop, "ByteArray"))) {
		fprintf(stderr, "primitiveRewindir: invalid argument, expected an ByteArray\n");
		return interpreterProxy->pop(2),interpreterProxy->push(interpreterProxy->signed32BitIntegerFor(-6));
	}
	dirStream = pointerFrom(dirPointerOop);
	if (dirStream == null) {
		return interpreterProxy->pop(2),interpreterProxy->push(interpreterProxy->signed32BitIntegerFor(-6));
	}
	rewinddir(dirStream->dp);
	interpreterProxy->pop(2);
	interpreterProxy->push(dirPointerOop);
	return null;
}


/*	Answer a string containing the version string for this plugin. */

EXPORT(sqInt) primitiveVersionString(void) {
	interpreterProxy->popthenPush(1, stringFromCString(versionString()));
	return null;
}


/*	Call stat() on cPathName, storing the results in
	the buffer at statBufPointer. */

static sqInt putLStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop) {
    char cLinkName[PATH_MAX];
    char *cLinkPtr = (char *) &cLinkName;
    sqInt len;
    sqInt result;
    sqInt status;

	
# if (HAVE_LSTAT == 1)  // Platforms which do not have lstat() should #define HAVE_LSTAT 0
	result = lstat(cPathName, statBufPointer);
	if (result != 0) {
		return -3;
	}
	if ((S_ISLNK(statBufPointer->st_mode)) == 0) {
		*fileNameOop = interpreterProxy->nilObject();
	} else {
		len = readLinkintomaxLength(cPathName, cLinkPtr, PATH_MAX);
		if (len < 0) {
			return len;
		}
		status = byteArrayFromCStringto(cLinkPtr, fileNameOop);
		if (status != 0) {
			return status;
		}
	}
# else
	return -11;
# endif  // HAVE_LSTAT == 1
	
	return 0;
}


/*	Call stat() on cPathName, storing the results in
	the buffer at statBufPointer. */

static sqInt putStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop) {
    sqInt result;
    sqInt status;

	#ifdef WIN32
	TIME_ZONE_INFORMATION dtzi;
	#endif;
	result = stat(cPathName, statBufPointer);
	if (result != 0) {
		return -3;
	}
	
# if (defined(WIN32))  // The windows version of stat() looks like it doesn't handle dst properly.  Adjust for DST.  Remove this code if ever switching to cygwin stat().
	status = GetTimeZoneInformation(&dtzi);
	if (status == 2) {
		statBufPointer->st_atime -= 3600;
		statBufPointer->st_mtime -= 3600;
		statBufPointer->st_ctime -= 3600;
	}
# endif  // defined(WIN32)
	
	*fileNameOop = interpreterProxy->nilObject();
	return 0;
}


/*	Get the target filename of the supplied symbolic link. */

static size_t readLinkintomaxLength(char *cPathName, char *cLinkPtr, size_t maxLength) {
    size_t len;

	
# if (defined(WIN32))  // This should never be called on WIN32, just indicate failure
	len = -1;
# else
	len = readlink(cPathName, cLinkPtr, maxLength);
# endif  // defined(WIN32)
	
	if (len < 0) {
		fprintf(stderr, "FileAttributesPlugin: unable to readlink(): %d\n", len);
		return -8;
	}
	cLinkPtr[len] = 0;
	return len;
}


/*	Note: This is coded so that is can be run from Squeak. */

EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter) {
    sqInt ok;

	interpreterProxy = anInterpreter;
	ok = interpreterProxy->majorVersion() == VM_PROXY_MAJOR;
	if (ok == 0) {
		return 0;
	}
	ok = interpreterProxy->minorVersion() >= VM_PROXY_MINOR;
	return ok;
}


/*	Size of a C pointer on this machine */

static sqInt sizeOfPointer(void) {
	return sizeof(void *);
}


/*	Answer an Integer object for aPositiveInteger. If the value is too large
	to fit in an SmallInteger, then answer a LargePositiveInteger. Note that
	smallIntegerMaxVal is a class variable with an initialization value determined
	when this class is translated to C code; see my #declareCVarsIn: class method. */

static sqInt smallOrLargeIntegerObjectFor(sqInt aPositiveInteger) {
	if (aPositiveInteger > smallIntegerMaxVal) {
		return ((aPositiveInteger << 1) | 1);
	} else {
		return interpreterProxy->positive32BitIntegerFor(aPositiveInteger);
	}
	return null;
}


/*	Answer a file entry array from the supplied statBufPointer */

static sqInt statArrayFortoArrayfromfileName(char *cPathName, sqInt attributeArray, struct stat *statBufPointer, sqInt fileNameOop) {
    time_t creationDate;
    sqInt index;
    sqInt sizeIfFile;
    sqInt status;

	if ((S_ISDIR(statBufPointer->st_mode)) == 0) {
		sizeIfFile = statBufPointer->st_size;
	} else {
		sizeIfFile = 0;
	}
	index = 0;
	interpreterProxy->storePointerofObjectwithValue(index, attributeArray, fileNameOop);

	/* 1 */

	index += 1;
	interpreterProxy->storePointerofObjectwithValue(index, attributeArray, smallOrLargeIntegerObjectFor(statBufPointer->st_mode));

	/* 2 */

	index += 1;
	interpreterProxy->storePointerofObjectwithValue(index, attributeArray, interpreterProxy->positive64BitIntegerFor(statBufPointer->st_ino));

	/* 3 */

	index += 1;
	interpreterProxy->storePointerofObjectwithValue(index, attributeArray, interpreterProxy->positive64BitIntegerFor(statBufPointer->st_dev));

	/* 4 */

	index += 1;
	interpreterProxy->storePointerofObjectwithValue(index, attributeArray, interpreterProxy->positive64BitIntegerFor(statBufPointer->st_nlink));

	/* 5 */

	index += 1;
	interpreterProxy->storePointerofObjectwithValue(index, attributeArray, smallOrLargeIntegerObjectFor(statBufPointer->st_uid));

	/* 6 */

	index += 1;
	interpreterProxy->storePointerofObjectwithValue(index, attributeArray, smallOrLargeIntegerObjectFor(statBufPointer->st_gid));

	/* 7 */

	index += 1;
	interpreterProxy->storePointerofObjectwithValue(index, attributeArray, smallOrLargeIntegerObjectFor(sizeIfFile));

	/* 8 */

	index += 1;
	interpreterProxy->storePointerofObjectwithValue(index, attributeArray, oopFromTimeT(statBufPointer->st_atime));

	/* 9 */

	index += 1;
	interpreterProxy->storePointerofObjectwithValue(index, attributeArray, oopFromTimeT(statBufPointer->st_mtime));

	/* 10 */

	index += 1;
	interpreterProxy->storePointerofObjectwithValue(index, attributeArray, oopFromTimeT(statBufPointer->st_ctime));

	/* 11 */

	index += 1;
	
# if (defined(WIN32))  // windows supports creation date
	status = fileCreationTimeForlengthto(cPathName, strlen(cPathName), &creationDate);
	if (status == 0) {
		interpreterProxy->storePointerofObjectwithValue(index, attributeArray, oopFromTimeT(creationDate));
	} else {
		interpreterProxy->storePointerofObjectwithValue(index, attributeArray, interpreterProxy->nilObject());
	}
# else
	interpreterProxy->storePointerofObjectwithValue(index, attributeArray, interpreterProxy->nilObject());
# endif  // defined(WIN32)
	
	return 0;
}


/*	Answer a new String copied from a null-terminated C string.
	Caution: This may invoke the garbage collector. */

static sqInt stringFromCString(const char *aCString) {
    sqInt len;
    sqInt newString;

	len = strlen(aCString);
	newString = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classString(), len);
	strncpy(interpreterProxy->arrayValueOf(newString), aCString, len);
	return newString;
}


/*	Answer a string containing the version string for this plugin. */

static char * versionString(void) {
    static char version[]= "1.0.0-dev22";

	return version;
}


/*	Answer a single element Array containing the supplied error code. */

static sqInt wrappedErrorCode(sqInt aNumber) {
    sqInt newArray;

	newArray = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classArray(), 1);
	interpreterProxy->storePointerofObjectwithValue(0, newArray, interpreterProxy->signed32BitIntegerFor(aNumber));
	return newArray;
}


#ifdef SQUEAK_BUILTIN_PLUGIN


void* FileAttributesPlugin_exports[][3] = {
	{"FileAttributesPlugin", "checkAccessmodeto", (void*)checkAccessmodeto},
	{"FileAttributesPlugin", "primitiveFileMasks", (void*)primitiveFileMasks},
	{"FileAttributesPlugin", "primitiveVersionString", (void*)primitiveVersionString},
	{"FileAttributesPlugin", "primitiveClosedir", (void*)primitiveClosedir},
	{"FileAttributesPlugin", "primitiveRewinddir", (void*)primitiveRewinddir},
	{"FileAttributesPlugin", "getModuleName", (void*)getModuleName},
	{"FileAttributesPlugin", "primitiveLogicalDrives", (void*)primitiveLogicalDrives},
	{"FileAttributesPlugin", "setInterpreter", (void*)setInterpreter},
	{"FileAttributesPlugin", "primitiveOpendir", (void*)primitiveOpendir},
	{"FileAttributesPlugin", "primitiveFileExists", (void*)primitiveFileExists},
	{"FileAttributesPlugin", "primitivePathMax", (void*)primitivePathMax},
	{"FileAttributesPlugin", "primitiveFileAttribute", (void*)primitiveFileAttribute},
	{"FileAttributesPlugin", "primitiveFileAttributes", (void*)primitiveFileAttributes},
	{"FileAttributesPlugin", "primitiveReaddir", (void*)primitiveReaddir},
	{NULL, NULL, NULL}
};


#endif /* ifdef SQ_BUILTIN_PLUGIN */

